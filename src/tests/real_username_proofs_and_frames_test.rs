//! Tests using real UsernameProof and FrameAction examples from Farcaster Hub
//!
//! These tests use real data found by scanning recent blocks.
//! The test fixtures are generated by running: cargo run --bin find_username_proofs_and_frames

#[cfg(test)]
mod real_examples_tests {
    use serde_json::Value;

    use crate::database::Database;
    use crate::models::ShardBlockInfo;
    use crate::sync::shard_processor::flush_batched_data;
    use crate::sync::shard_processor::BatchedData;

    /// Helper to create test database
    /// Uses main database if SNAPRAG_CONFIG is set, otherwise uses config.test.toml
    async fn setup_test_db() -> Database {
        // Allow using main database if explicitly configured via SNAPRAG_CONFIG
        let config_path =
            std::env::var("SNAPRAG_CONFIG").unwrap_or_else(|_| "config.toml".to_string()); // Default to main config

        let config =
            crate::config::AppConfig::from_file(&config_path).expect("Failed to load config");

        println!("üìä Using database config from: {}", config_path);
        println!("   Database URL: {}", mask_db_url(&config.database_url()));

        Database::from_config(&config)
            .await
            .expect("Failed to create database")
    }

    /// Mask database URL for safe logging
    fn mask_db_url(url: &str) -> String {
        if let Some(start) = url.find("://") {
            if let Some(at_pos) = url[start + 3..].find('@') {
                let before_creds = &url[..start + 3];
                let after_at = &url[start + 3 + at_pos..];
                if let Some(colon_pos) = url[start + 3..start + 3 + at_pos].find(':') {
                    let username = &url[start + 3..start + 3 + colon_pos];
                    return format!("{before_creds}{username}:****{after_at}");
                }
            }
        }
        url.to_string()
    }

    /// Helper to cleanup test data by message_hash
    async fn cleanup_by_message_hash(db: &Database, message_hash: &[u8]) {
        let cleanup_queries = vec![
            "DELETE FROM username_proofs WHERE message_hash = $1",
            "DELETE FROM frame_actions WHERE message_hash = $1",
        ];

        for query in cleanup_queries {
            sqlx::query(query)
                .bind(message_hash)
                .execute(db.pool())
                .await
                .ok();
        }
    }

    /// Load test fixtures from JSON files
    fn load_fixtures(filename: &str) -> Vec<Value> {
        let path = format!("tests/fixtures/{}", filename);
        let content = std::fs::read_to_string(&path)
            .unwrap_or_else(|_| panic!("Failed to read fixture file: {}", path));
        serde_json::from_str(&content).expect("Failed to parse fixture JSON")
    }

    #[tokio::test]
    #[ignore = "Requires fixtures and database access"]
    async fn test_real_username_proofs() {
        let db = setup_test_db().await;
        let examples = load_fixtures("username_proof_examples.json");

        if examples.is_empty() {
            println!("‚ö†Ô∏è  No UsernameProof fixtures found. Run: cargo run --bin find_username_proofs_and_frames");
            return;
        }

        for (idx, example) in examples.iter().enumerate() {
            let fid = example["fid"].as_u64().unwrap() as i64;
            let timestamp = example["timestamp"].as_u64().unwrap() as i64;
            let message_hash_hex = example["message_hash"].as_str().unwrap();
            let message_hash = hex::decode(message_hash_hex).expect("Invalid hex");

            // Cleanup before test
            cleanup_by_message_hash(&db, &message_hash).await;

            let body = example["body"].as_object().unwrap();
            let name = body["name"].as_str().unwrap();
            let owner_hex = body["owner"].as_str().unwrap();
            let owner = hex::decode(owner_hex).expect("Invalid owner hex");
            let signature_hex = body["signature"].as_str().unwrap();
            let signature = hex::decode(signature_hex).expect("Invalid signature hex");
            let username_type = body["type"].as_u64().unwrap() as i16;

            println!(
                "  Testing UsernameProof: FID={}, username={}, type={}",
                fid, name, username_type
            );

            let shard_id = example["shard_id"].as_u64().unwrap() as u32;
            let block_number = example["block_number"].as_u64().unwrap_or(0);
            let shard_info = ShardBlockInfo {
                shard_id,
                block_height: block_number,
                transaction_fid: fid as u64,
                timestamp: timestamp as u64,
            };

            let mut batched = BatchedData::new();
            batched.username_proofs.push((
                fid,
                name.to_string(),
                owner.clone(),
                signature.clone(),
                username_type,
                timestamp,
                message_hash.clone(),
                shard_info,
            ));

            flush_batched_data(&db, batched)
                .await
                .expect("Failed to flush UsernameProof");

            // Verify insertion (use message_hash for unique lookup)
            let result: Option<(String, i16, Vec<u8>, i64)> = sqlx::query_as(
                "SELECT username, username_type, owner, timestamp 
                 FROM username_proofs 
                 WHERE message_hash = $1",
            )
            .bind(&message_hash)
            .fetch_optional(db.pool())
            .await
            .expect("Failed to query");

            assert!(result.is_some(), "UsernameProof should be inserted");
            let (stored_username, stored_type, stored_owner, _) = result.unwrap();
            assert_eq!(stored_username, name);
            assert_eq!(stored_type, username_type);
            assert_eq!(stored_owner, owner);

            // Cleanup after test
            cleanup_by_message_hash(&db, &message_hash).await;

            println!(
                "‚úÖ Real UsernameProof example {} passed (FID: {}, username: {})",
                idx + 1,
                fid,
                name
            );
        }
    }

    #[tokio::test]
    #[ignore = "Requires fixtures and database access"]
    async fn test_real_frame_actions() {
        let db = setup_test_db().await;
        let examples = load_fixtures("frame_action_examples.json");

        if examples.is_empty() {
            println!("‚ö†Ô∏è  No FrameAction fixtures found. Run: cargo run --bin find_username_proofs_and_frames");
            return;
        }

        for (idx, example) in examples.iter().enumerate() {
            let fid = example["fid"].as_u64().unwrap() as i64;
            let timestamp = example["timestamp"].as_u64().unwrap() as i64;
            let message_hash_hex = example["message_hash"].as_str().unwrap();
            let message_hash = hex::decode(message_hash_hex).expect("Invalid hex");

            // Cleanup before test
            cleanup_by_message_hash(&db, &message_hash).await;

            let body = example["body"].as_object().unwrap();
            let url = body["url"].as_str().unwrap_or("").to_string();
            let button_index = body["button_index"]
                .as_u64()
                .and_then(|v| i32::try_from(v).ok());

            let cast_hash = body
                .get("cast_id")
                .and_then(|c| c.as_object())
                .and_then(|c| c.get("hash"))
                .and_then(|h| h.as_str())
                .and_then(|h| hex::decode(h).ok());
            let cast_fid = body
                .get("cast_id")
                .and_then(|c| c.as_object())
                .and_then(|c| c.get("fid"))
                .and_then(|f| f.as_u64())
                .and_then(|f| i64::try_from(f).ok());

            let input_text = body
                .get("input_text")
                .and_then(|t| t.as_str())
                .map(|s| s.to_string());
            let state = body
                .get("state")
                .and_then(|s| s.as_str())
                .and_then(|s| hex::decode(s).ok());
            let transaction_id = body
                .get("transaction_id")
                .and_then(|t| t.as_str())
                .and_then(|t| hex::decode(t).ok());

            let shard_id = example["shard_id"].as_u64().unwrap() as u32;
            let block_number = example["block_number"].as_u64().unwrap_or(0);
            let shard_info = ShardBlockInfo {
                shard_id,
                block_height: block_number,
                transaction_fid: fid as u64,
                timestamp: timestamp as u64,
            };

            let mut batched = BatchedData::new();
            batched.frame_actions.push((
                fid,
                url.clone(),
                button_index,
                cast_hash.clone(),
                cast_fid,
                input_text.clone(),
                state.clone(),
                transaction_id.clone(),
                timestamp,
                message_hash.clone(),
                shard_info,
            ));

            flush_batched_data(&db, batched)
                .await
                .expect("Failed to flush FrameAction");

            // Verify insertion
            let result: Option<(
                String,
                Option<i32>,
                Option<Vec<u8>>,
                Option<i64>,
                Option<String>,
                i64,
            )> = sqlx::query_as(
                "SELECT url, button_index, cast_hash, cast_fid, input_text, timestamp 
                 FROM frame_actions 
                 WHERE message_hash = $1",
            )
            .bind(&message_hash)
            .fetch_optional(db.pool())
            .await
            .expect("Failed to query");

            assert!(result.is_some(), "FrameAction should be inserted");
            let (stored_url, stored_button, stored_cast_hash, stored_cast_fid, stored_input, _) =
                result.unwrap();
            assert_eq!(stored_url, url);
            assert_eq!(stored_button, button_index);
            assert_eq!(stored_cast_hash, cast_hash);
            assert_eq!(stored_cast_fid, cast_fid);
            assert_eq!(stored_input, input_text);

            // Cleanup after test
            cleanup_by_message_hash(&db, &message_hash).await;

            println!(
                "‚úÖ Real FrameAction example {} passed (FID: {}, URL: {})",
                idx + 1,
                fid,
                url
            );
        }
    }
}
